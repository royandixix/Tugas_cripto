<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classical Ciphers</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-light">
    <div class="container my-5 p-4 bg-white rounded shadow">
        <h1 class="text-center text-secondary">Classical Ciphers</h1>
        <form>
            <div class="mb-3">
                <label for="cipherType" class="form-label">Select Cipher:</label>
                <select id="cipherType" class="form-select">
                    <option value="vigenere">Vigenere Cipher (alphabet letters)</option>
                    <option value="extendedVigenere">Extended Vigenere Cipher (256 ASCII characters)</option>
                    <option value="playfair">Playfair Cipher (5x5 matrix)</option>
                    <option value="enigma">Enigma Cipher</option>
                    <option value="otp">One-Time Pad</option>
                </select>
            </div>

            <div class="mb-3">
                <label for="inputText" class="form-label">Input Text:</label>
                <textarea id="inputText" class="form-control" rows="5" placeholder="Enter text or drop a file"></textarea>
            </div>

            <div class="mb-3">
                <label for="key" class="form-label">Key:</label>
                <input type="text" id="key" class="form-control" placeholder="Enter encryption key">
            </div>

            <div class="mb-3">
                <button type="button" class="btn btn-primary" onclick="encrypt()">Encrypt</button>
                <button type="button" class="btn btn-secondary" onclick="decrypt()">Decrypt</button>
                <input type="file" id="fileInput" style="display: none">
                <button type="button" class="btn btn-warning" onclick="document.getElementById('fileInput').click()">Upload File</button>
            </div>
        </form>

        <div class="output mt-4">
            <h3>Output:</h3>
            <p id="outputText" class="border rounded p-2 bg-light"></p>
            <button class="btn btn-success" onclick="downloadOutput()">Download Output</button>
        </div>
    </div>

    <script>
        // Vigen√®re Cipher Functions
        function vigenereEncrypt(text, key, extended = false) {
            let result = "";
            let keyIndex = 0;

            for (let i = 0; i < text.length; i++) {
                let char = text[i];
                if (!extended && !char.match(/[a-zA-Z]/)) continue;

                let charCode = extended ? text.charCodeAt(i) : text.toUpperCase().charCodeAt(i) - 65;
                let keyChar = key[keyIndex % key.length];
                let keyCode = extended ? keyChar.charCodeAt(0) : keyChar.toUpperCase().charCodeAt(0) - 65;

                result += String.fromCharCode((charCode + keyCode) % (extended ? 256 : 26) + (extended ? 0 : 65));
                keyIndex++;
            }

            return result;
        }

        function vigenereDecrypt(text, key, extended = false) {
            let result = "";
            let keyIndex = 0;

            for (let i = 0; i < text.length; i++) {
                let char = text[i];
                if (!extended && !char.match(/[a-zA-Z]/)) continue;

                let charCode = extended ? text.charCodeAt(i) : text.toUpperCase().charCodeAt(i) - 65;
                let keyChar = key[keyIndex % key.length];
                let keyCode = extended ? keyChar.charCodeAt(0) : keyChar.toUpperCase().charCodeAt(0) - 65;

                result += String.fromCharCode((charCode - keyCode + (extended ? 256 : 26)) % (extended ? 256 : 26) + (extended ? 0 : 65));
                keyIndex++;
            }

            return result;
        }

        // Playfair Cipher Functions
        function generatePlayfairMatrix(key) {
            const matrix = [];
            const alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"; // Combine I and J
            const usedChars = new Set();

            // Add key characters to the matrix
            for (let char of key.toUpperCase()) {
                if (char === 'J') char = 'I'; // Treat 'J' as 'I'
                if (!usedChars.has(char) && char.match(/[A-Z]/)) {
                    matrix.push(char);
                    usedChars.add(char);
                }
            }

            // Add remaining alphabet characters
            for (let char of alphabet) {
                if (!usedChars.has(char)) {
                    matrix.push(char);
                }
            }

            return matrix;
        }

        function findPositionInMatrix(matrix, char) {
            const pos = matrix.indexOf(char);
            return {
                row: Math.floor(pos / 5),
                col: pos % 5
            };
        }

        function playfairEncrypt(text, key) {
            const matrix = generatePlayfairMatrix(key);
            text = text.toUpperCase().replace(/J/g, 'I').replace(/[^A-Z]/g, '');

            // Prepare text into digraphs
            let prepared = '';
            for (let i = 0; i < text.length; i++) {
                prepared += text[i];
                if (i + 1 < text.length && text[i] === text[i + 1]) {
                    prepared += 'X'; // Insert 'X' for repeated letters
                }
            }
            if (prepared.length % 2 !== 0) prepared += 'X'; // Pad with 'X' if odd length

            // Split into pairs and encrypt each digraph
            let result = "";
            for (let i = 0; i < prepared.length; i += 2) {
                const pos1 = findPositionInMatrix(matrix, prepared[i]);
                const pos2 = findPositionInMatrix(matrix, prepared[i + 1]);

                if (pos1.row === pos2.row) {
                    result += matrix[pos1.row * 5 + (pos1.col + 1) % 5];
                    result += matrix[pos2.row * 5 + (pos2.col + 1) % 5];
                } else if (pos1.col === pos2.col) {
                    result += matrix[((pos1.row + 1) % 5) * 5 + pos1.col];
                    result += matrix[((pos2.row + 1) % 5) * 5 + pos2.col];
                } else {
                    result += matrix[pos1.row * 5 + pos2.col];
                    result += matrix[pos2.row * 5 + pos1.col];
                }
            }

            return result;
        }

        function playfairDecrypt(text, key) {
            const matrix = generatePlayfairMatrix(key);
            text = text.toUpperCase().replace(/J/g, 'I').replace(/[^A-Z]/g, '');

            // Split into pairs and decrypt each digraph
            let result = "";
            for (let i = 0; i < text.length; i += 2) {
                const pos1 = findPositionInMatrix(matrix, text[i]);
                const pos2 = findPositionInMatrix(matrix, text[i + 1]);

                if (pos1.row === pos2.row) {
                    result += matrix[pos1.row * 5 + (pos1.col - 1 + 5) % 5];
                    result += matrix[pos2.row * 5 + (pos2.col - 1 + 5) % 5];
                } else if (pos1.col === pos2.col) {
                    result += matrix[((pos1.row - 1 + 5) % 5) * 5 + pos1.col];
                    result += matrix[((pos2.row - 1 + 5) % 5) * 5 + pos2.col];
                } else {
                    result += matrix[pos1.row * 5 + pos2.col];
                    result += matrix[pos2.row * 5 + pos1.col];
                }
            }

            return result.replace(/X/g, ''); // Remove inserted 'X's
        }

        // Enigma Cipher Class
        class EnigmaMachine {
            constructor() {
                this.rotors = [
                    'EKMFLGDQVZNTOWYHXUSPAIBRCJ',
                    'AJDKSIRUXBLHWTMCQGZNPYFVOE',
                    'BDFHJLCPRTXVZNYEIWGAKMUSQO'
                ];
                this.reflector = 'YRUHQSLDPXNGOKMIEBFZCWVJAT';
                this.rotorPositions = [0, 0, 0];
            }

            rotateRotor(rotor) {
                this.rotorPositions[rotor] = (this.rotorPositions[rotor] + 1) % 26;
                if (this.rotorPositions[rotor] === 0 && rotor < 2) {
                    this.rotateRotor(rotor + 1);
                }
            }

            encryptChar(char) {
                let pos = char.charCodeAt(0) - 65;
                // Pass through rotors
                for (let i = 0; i < 3; i++) {
                    pos = (pos + this.rotorPositions[i]) % 26;
                    pos = this.rotors[i].charCodeAt(pos) - 65;
                }
                // Pass through reflector
                pos = this.reflector.charCodeAt(pos) - 65;
                // Pass back through rotors
                for (let i = 2; i >= 0; i--) {
                    pos = this.rotors[i].indexOf(String.fromCharCode(pos + 65));
                    pos = (pos - this.rotorPositions[i] + 26) % 26;
                }
                return String.fromCharCode(pos + 65);
            }

            encrypt(text) {
                let result = '';
                for (let char of text.toUpperCase()) {
                    if (char.match(/[A-Z]/)) {
                        result += this.encryptChar(char);
                        this.rotateRotor(0);
                    } else {
                        result += char;
                    }
                }
                return result;
            }
        }

        // Encryption/Decryption Dispatcher
        function encrypt() {
            const cipherType = document.getElementById("cipherType").value;
            const inputText = document.getElementById("inputText").value;
            const key = document.getElementById("key").value;

            let output;
            switch (cipherType) {
                case "vigenere":
                    output = vigenereEncrypt(inputText, key);
                    break;
                case "extendedVigenere":
                    output = vigenereEncrypt(inputText, key, true);
                    break;
                case "playfair":
                    output = playfairEncrypt(inputText, key);
                    break;
                case "enigma":
                    const enigma = new EnigmaMachine();
                    output = enigma.encrypt(inputText);
                    break;
                case "otp":
                    output = "One-Time Pad requires a random key of the same length as the input.";
                    break;
                default:
                    output = "Invalid Cipher Type.";
                    break;
            }
            document.getElementById("outputText").textContent = output;
        }

        function decrypt() {
            const cipherType = document.getElementById("cipherType").value;
            const inputText = document.getElementById("inputText").value;
            const key = document.getElementById("key").value;

            let output;
            switch (cipherType) {
                case "vigenere":
                    output = vigenereDecrypt(inputText, key);
                    break;
                case "extendedVigenere":
                    output = vigenereDecrypt(inputText, key, true);
                    break;
                case "playfair":
                    output = playfairDecrypt(inputText, key);
                    break;
                case "enigma":
                    output = "Decryption for Enigma is not implemented in this version.";
                    break;
                case "otp":
                    output = "One-Time Pad requires a random key of the same length as the input.";
                    break;
                default:
                    output = "Invalid Cipher Type.";
                    break;
            }
            document.getElementById("outputText").textContent = output;
        }

        // Download Output
        function downloadOutput() {
            const outputText = document.getElementById("outputText").textContent;
            const blob = new Blob([outputText], {
                type: "text/plain"
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "output.txt";
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.min.js"></script>
</body>

</html>